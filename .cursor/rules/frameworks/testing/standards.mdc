---
description: Testing standards with tiered mocks and reality verification
globs: ["**/*.test.*", "**/__tests__/**"]
alwaysApply: false
tags: [testing, mocks, unit, integration, e2e]
---

# Testing Standards (Tiered Mocks, Verified Against Reality)

## Principles
- Prefer small, fast tests near the code; grow realism as you move up the test pyramid.
- Mocks are acceptable at lower levels when they are verified to match reality and do not hide defects.
- Avoid global toggles that bypass tests; failures must be fixed or the test adjusted with rationale.

## Test Pyramid and Mocking Strategy
1. Unit tests (allow mocks) — fast feedback on small units
   - Use test doubles for IO and slow deps (network, DB, filesystem).
   - Keep mocks minimal; prefer fakes over complex behaviors.
2. Integration tests (fewer mocks)
   - Replace unit-level mocks with real adapters where feasible.
   - Validate wiring across module boundaries and data contracts.
3. End-to-end (no mocks if possible)
   - Exercise the system through public interfaces.
   - Only mock external third‑party services you do not control.

## Mock Verification (Make Mocks Match Reality)
Use one or more techniques so mocks do not drift from the real world:
- Contract tests: Assert provider/consumer agree on request/response shapes.
- Golden files/snapshots: Record real responses and reuse as fixtures; refresh on schema changes.
- Schema/type guards: Validate fixtures against JSON Schema or TypeScript types at test load.
- Parity runs: Periodically hit real services in CI nightly jobs to detect drift.

## When To Mock
- Allowed: low‑level unit tests for adapters, network clients, DB gateways.
- Allowed: failure scenarios that are costly/risky to reproduce (timeouts, 5xx).
- Avoid: mocking your own domain logic; prefer real collaboration between domain services.
- Avoid: mocks in E2E unless isolating non-deterministic third parties.

## Quality Bars
- Unit: fast (<100ms), isolated, deterministic. High branch/path coverage.
- Integration: validate cross‑module contracts and realistic data flows.
- E2E: validate critical paths; focus on user‑visible correctness.

## Test Isolation

### Core Principle
**Tests must be isolated by default** — data from one test suite should not affect another, and tests within a suite should not depend on each other unless explicitly necessary.

### Isolation Requirements
- **Between test suites**: Each test suite must clean up its own state and not rely on data created by other suites.
- **Between tests**: Each test must set up and tear down its own data. Tests should be able to run in any order.
- **Shared state**: Only share data between tests when explicitly necessary and documented with clear rationale.
- **Database/state**: Use transactions, test databases, or fixtures that are reset between tests. Never rely on shared mutable state.

### Implementation Guidelines
- **Setup/teardown**: Use `beforeEach`/`afterEach` or `beforeAll`/`afterAll` hooks to establish and clean up test state.
- **Transaction rollback**: Wrap database-dependent tests in transactions that roll back after each test.
- **Isolated test databases**: Use separate test databases or schemas per test suite when possible.
- **Fixtures**: Create fresh test data per test rather than reusing data across tests.
- **Global state**: Avoid global variables, singletons, or shared caches that persist between tests.
- **Concurrent execution**: Tests should be safe to run in parallel without interference.

### Exceptions and Documentation
- **Shared fixtures**: When sharing data is necessary (e.g., expensive setup, read-only reference data), document the rationale and ensure the shared state is immutable or reset between uses.
- **Integration test dependencies**: Integration tests may share a database schema, but each test must still clean up its own modifications.
- **E2E scenarios**: E2E tests may require shared state to simulate real user workflows; document these dependencies clearly.

## Fixture Hygiene
- Keep fixtures small and representative; remove unused fields.
- Co-locate fixtures with tests; document provenance (e.g., captured on 2025‑10‑29).
- Validate fixtures against schemas/types on load.

## Tooling Hints
- TypeScript: use `zod`/`io-ts` or JSON Schema to validate mock payloads.
- API: maintain OpenAPI and generate client/server types; use them in tests.
- UI: prefer Testing Library; avoid implementation‑coupled selectors.

## Documentation and Ownership
- Each mocked interface must have a short README describing its real contract, how fixtures were captured, and how to refresh them.
- Add a scheduled job or checklist to refresh golden files after API/schema changes.

## References
- Martin Fowler — “Mocks Aren’t Stubs”
- Google Testing Blog — Testing on the Toilet (test doubles, hermetic tests)
- Thoughtworks Tech Radar — Testing strategies and contract testing

