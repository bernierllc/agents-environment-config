---
description: Testing standards with tiered mocks and reality verification
globs: ["**/*.test.*", "**/__tests__/**"]
alwaysApply: false
tags: [testing, mocks, unit, integration, e2e]
---

# Testing Standards (Tiered Mocks, Verified Against Reality)

## Principles
- Prefer small, fast tests near the code; grow realism as you move up the test pyramid.
- **CRITICAL: All mocks in testing MUST be tested to match the ACTUAL thing they are mocking, otherwise the mocks are fucking useless and only cause problems.**
- Mocks are acceptable at lower levels when they are verified to match reality and do not hide defects.
- Avoid global toggles that bypass tests; failures must be fixed or the test adjusted with rationale.

## Test Pyramid and Mocking Strategy
1. Unit tests (allow mocks) — fast feedback on small units
   - Use test doubles for IO and slow deps (network, DB, filesystem).
   - Keep mocks minimal; prefer fakes over complex behaviors.
2. Integration tests (fewer mocks)
   - Replace unit-level mocks with real adapters where feasible.
   - Validate wiring across module boundaries and data contracts.
3. End-to-end (no mocks if possible)
   - Exercise the system through public interfaces.
   - Only mock external third‑party services you do not control.

## UI Testing Workflow

**CRITICAL: For creating UI tests, use Playwright MCP with the actual UI to identify how the actual UI works in order to write or validate what is in the Playwright tests. Then run the Playwright tests and make sure they work against the actual UI as it actually works.**

### UI Test Creation Process
1. **Discovery Phase**: Use Playwright MCP to interact with the actual running UI
   - Navigate to the UI and explore its behavior
   - Identify selectors, interactions, and states through actual usage
   - Document how the UI actually responds to user actions
2. **Test Writing**: Write Playwright tests based on actual UI behavior discovered
   - Use selectors and interactions verified against the real UI
   - Ensure tests match the actual UI workflow, not assumptions
3. **Validation**: Run tests against the actual UI and verify they work correctly
   - Tests must pass against the real UI as it actually works
   - Adjust tests if UI behavior differs from assumptions
   - Never write tests without first verifying against the actual UI

## Mock Verification (Make Mocks Match Reality)

**CRITICAL: All mocks in testing MUST be tested to match the ACTUAL thing they are mocking, otherwise the mocks are fucking useless and only cause problems.**

Use one or more techniques so mocks do not drift from the real world:
- Contract tests: Assert provider/consumer agree on request/response shapes.
- Golden files/snapshots: Record real responses and reuse as fixtures; refresh on schema changes.
- Schema/type guards: Validate fixtures against JSON Schema or TypeScript types at test load.
- Parity runs: Periodically hit real services in CI nightly jobs to detect drift.

## When To Mock
- Allowed: low‑level unit tests for adapters, network clients, DB gateways.
- Allowed: failure scenarios that are costly/risky to reproduce (timeouts, 5xx).
- Avoid: mocking your own domain logic; prefer real collaboration between domain services.
- Avoid: mocks in E2E unless isolating non-deterministic third parties.

## Quality Bars
- Unit: fast (<100ms), isolated, deterministic. High branch/path coverage.
- Integration: validate cross‑module contracts and realistic data flows.
- E2E: validate critical paths; focus on user‑visible correctness.

## Test Isolation

### Core Principle
**Tests must be isolated by default** — data from one test suite should not affect another, and tests within a suite should not depend on each other unless explicitly necessary.

### Isolation Requirements
- **Between test suites**: Each test suite must clean up its own state and not rely on data created by other suites.
- **Between tests**: Each test must set up and tear down its own data. Tests should be able to run in any order.
- **Shared state**: Only share data between tests when explicitly necessary and documented with clear rationale.
- **Database/state**: Use transactions, test databases, or fixtures that are reset between tests. Never rely on shared mutable state.

### Implementation Guidelines
- **Setup/teardown**: Use `beforeEach`/`afterEach` or `beforeAll`/`afterAll` hooks to establish and clean up test state.
- **Transaction rollback**: Wrap database-dependent tests in transactions that roll back after each test.
- **Isolated test databases**: Use separate test databases or schemas per test suite when possible.
- **Fixtures**: Create fresh test data per test rather than reusing data across tests.
- **Global state**: Avoid global variables, singletons, or shared caches that persist between tests.
- **Concurrent execution**: Tests should be safe to run in parallel without interference.

### Exceptions and Documentation
- **Shared fixtures**: When sharing data is necessary (e.g., expensive setup, read-only reference data), document the rationale and ensure the shared state is immutable or reset between uses.
- **Integration test dependencies**: Integration tests may share a database schema, but each test must still clean up its own modifications.
- **E2E scenarios**: E2E tests may require shared state to simulate real user workflows; document these dependencies clearly.

## Fixture Hygiene
- Keep fixtures small and representative; remove unused fields.
- Co-locate fixtures with tests; document provenance (e.g., captured on 2025‑10‑29).
- Validate fixtures against schemas/types on load.

## Tooling Hints
- TypeScript: use `zod`/`io-ts` or JSON Schema to validate mock payloads.
- API: maintain OpenAPI and generate client/server types; use them in tests.
- UI: prefer Testing Library; avoid implementation‑coupled selectors.
- **UI Testing**: Use Playwright MCP with the actual UI to discover behavior before writing tests. Always verify tests work against the actual UI.

## Documentation and Ownership
- Each mocked interface must have a short README describing its real contract, how fixtures were captured, and how to refresh them.
- Add a scheduled job or checklist to refresh golden files after API/schema changes.

## References
- Martin Fowler — “Mocks Aren’t Stubs”
- Google Testing Blog — Testing on the Toilet (test doubles, hermetic tests)
- Thoughtworks Tech Radar — Testing strategies and contract testing

